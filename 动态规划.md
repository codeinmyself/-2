## 基本概念
### DP
对各维状态进行分阶段、有顺序、无重复、决策性的遍历求解

## 动规标准套路
以背包问题为例。
第一步，明确两点：状态和选择。状态即背包的容量 & 可选择的物品。选择即装进背包或不装进背包。
第二步，明确dp数组的定义。因为状态有两个，所以定义二维dp数组。
dp[i][w],即对于前i个物品，当前背包的容量为w，可以装的最大价值为dp[i][w]。
第三步，根据选择，思考状态转移的逻辑。
```java
int knapsack(int W, int N, int[] wt, int[] val) {
    // base case 已初始化
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        for (int w = 1; w <= W; w++) {
            if (w - wt[i - 1] < 0) {
                // 这种情况下只能选择不装入背包
                dp[i][w] = dp[i - 1][w];
            } else {
                // 装入或者不装入背包，择优
                dp[i][w] = Math.max(
                    dp[i - 1][w - wt[i-1]] + val[i-1], 
                    dp[i - 1][w]
                );
            }
        }
    }
    
    return dp[N][W];
}
```

### 无后效性
DP要求已求解的问题不受后续阶段的影响。
DP对状态空间的遍历构成DAG，遍历顺序就是该DAG的一个拓扑序。

### 最优子结构
当动态规划用于求解最优化的问题时，下一阶段的最优解应该能由前面各阶段子问题的最优解导出。

### 重复子问题
具有可重复的求解过程

### 阶段（子问题）
每个子问题的求解过程都构成一个阶段。
在完成前一个阶段的计算中，才会执行下一阶段的计算。

### 状态、转移、决策
DAG中的节点是DP的状态；
DAG中的边是状态之间的转移；
转移的选取时DP中的决策。

## 分类

### 线性动态规划
具有线性阶段划分的 DP 问题

#### 单串DP
有时只有单串上的位置不足以表示状态，需要同时附加一个维度k,一般k有长度、个数、次数、颜色等含义。
另，所附加的维度有时候可以是多个，如k1，k2.

##### 没有附加状态维度
最大子串和，最长上升序列，打家劫舍

##### 附加一维状态维度
最大连续1的个数

##### 附加多维状态维度
买卖股票的最佳时机

#### 双串DP
dp[i][j],i和j分别是两个串上的位置，没有附加维度。

#### 区间DP
减治型
分治型

#### 背包DP

##### 01背包
组合问题
最值问题
###### 例题
[零钱兑换](https://leetcode.cn/problems/coin-change/)
```java
public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
        int[] dp = new int[amount + 1];
        // 用超出最大值的数据 初始化dp数组
        Arrays.fill(dp, max);
        dp[0] = 0; 
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        // 如果dp[amount]>amount,说明无法兑换
        return dp[amount] > amount ? -1 : dp[amount];
    }
 ```   
##### 完全背包
组合问题
最值问题
###### 例题
[零钱兑换2](https://leetcode.cn/problems/coin-change-2/solution/ling-qian-dui-huan-ii-by-leetcode-soluti-f7uh/)
```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                dp[i] += dp[i - coin];
            }
        }
        return dp[amount];
    }
}
```
另一种写法：
```java
int change(int amount, int[] coins) {
    int n = coins.length;
    int[][] dp = int[n + 1][amount + 1];
    // base case
    for (int i = 0; i <= n; i++) 
        dp[i][0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= amount; j++)
            if (j - coins[i-1] >= 0)
                dp[i][j] = dp[i - 1][j] 
                         + dp[i][j - coins[i-1]];
            else 
                dp[i][j] = dp[i - 1][j];
    }
    return dp[n][amount];
}
```

对于面额为 coin 的硬币，当coin≤i≤amount 时，如果存在一种硬币组合的金额之和等于 i−coin，则在该硬币组合中增加一个面额为 coin 的硬币，即可得到一种金额之和等于 i 的硬币组合。因此需要遍历 coins，对于其中的每一种面额的硬币，更新数组dp 中的每个大于或等于该面额的元素的值。

#### 棋盘DP
dp[i][j],i和j是矩阵的横纵坐标。

### 树形DP
以节点的深度作为阶段的 DP 问题

### 图上DP

### 状态压缩DP
状态压缩动态规划是一类非常典型的动态规划，通常使用在 NP 问题的小规模求解中，虽然是指数级别的复杂度，但速度比搜索快

### 数位DP

### 前缀和
前缀和的预处理过程的推导方式就是线性DP。
但是前缀和本身就是一个足够大的话题，题目也很多，所以一般都会独立出来，自成一个体系。就好比把火锅放在餐饮里面是很正常的，但是火锅本身已经足够大了，一般在行业分析的时候都会把火锅单独分析。

#### HashMap维护前缀和

#### 单调栈维护前缀和

#### 单调队列维护前缀和

#### 线段树维护前缀和

#### 前缀和优化DP

#### 前缀积

#### 前缀异或

#### 差分

#### 树形前缀和

#### 频数前缀和

#### 二维前缀和

#### 前后缀信息预处理

### 概率DP

### 博弈DP
