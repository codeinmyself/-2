# 并查集

## 适用场景
连通性问题

## 思想
并查集的思想就是，同一个连通区域内的所有点的根节点是同一个

# 数组并查集

## 适用范围
默认节点编号是0~n-1

## 例题
[统计无向图中无法互相到达点对数](https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/)
[被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)
[省份数量](https://leetcode.cn/problems/number-of-provinces/)

## 模板
```java
// 并查集，背住，不然没用，要背就背最标准的和完整的，别去背某些题目的精简/修改版，一点儿用没有
class UnionFind {
    int size; // 连通区域个数
    private int[] roots;
    private int[] rank; // 按秩求并和按大小求并选择其中一种即可
    private int[] size;
    
    // 初始化节点，将每个节点的parent指向自己
    public UnionFind(int n) {
        roots = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            roots[i] = i;
            rank[i] = 1;
        }
        size=n;
    }

    
     /**
     * 直接查找
     */
    public int findDirect(int x) {
        if(roots[x] == x){
            return x;
        } else{
            return findDirect(roots[x]);  
        }
    }
    
    // 作用：查找i的根节点，并在查找时进行路径上节点的parent重置，即路径压缩，最终指向同一个parent节点
    public int find(int i) {
        if (i == roots[i]) { // 说明找到最顶层的parent了，递归终止
            return i;
        }
        return roots[i] = find(roots[i]); // 这是一个赋值语句，并直接将值返回，
        /**
         *  可写成：
         *          int result=find(roots[i]);
         *          roots[i]=result;
         *          return result;
         */
    }

    // 作用：合并p，q两点，一般是将后者作为父节点，逻辑是先分别find，然后链接
    public void unionDirect(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot != qRoot) {
            roots[pRoot] = qRoot;
            size--;
        }
    }
    
    
    /**
     * 按大小求并
     */
    public void unionBySize(int x, int y){
        int xRoot = find(x);
        int yRoot = find(y);
        // 根节点不同才求并
        if(xRoot != yRoot) {
            if(size[yRoot] <= size[xRoot]){
                roots[yRoot] = xRoot;
                size[xRoot] += size[yRoot];
            } else {
                roots[xRoot] = yRoot;
                size[yRoot] += size[xRoot];
            }
        }
    }
    
    /**
     * 按秩求并
     */
    public void unionByLevel(int x, int y){
        int xRoot = find(x);
        int yRoot = find(y);
        // 根节点相同不影响结果，最终还是会得到根节点指向自己的结果
        // 在不同集合元素求并操作较多时，省去xRoot != yRoot的判断效率较高
        if(rank[yRoot] <= rank[xRoot]){
            roots[yRoot] = xRoot;
        } else {
            roots[xRoot] = yRoot;
        }
        // 当两棵树秩相等且为不同集合时，新树的高度加1
        // 注意，秩较小的树的秩无需更新，因为每次求一个元素所在集合的高度都会先找到该集合的树的根
        if(rank[xRoot] == rank[yRoot] && xRoot != yRoot){
            rank[xRoot]++; 
        }
    }
    
    // 作用： 判断两点是否连通
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public int count() {
        return this.size;
    }
}
```
# 哈希并查集

## 适用范围
节点编号不是0~n-1

## 例题
[最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

## 模板
```java
private class UnionFind{

        Map<Integer, Integer> parents;

        public UnionFind(int[] nums){
            this.parents = new HashMap<>();
            for(int num : nums) this.parents.put(num, num); // 初始单元素集合，parent指向自己
        }

        public int find(int x){
            if(parents.get(x) == x) return x;
            parents.put(x, find(parents.get(x)));
            return parents.get(x);
        }

        public void union(int x, int y){
            int xParent = find(x);
            int yParent = find(y);
            if (xParent != yParent) {
                parents.put(xParent, yParent);
            }
        }
    }
  ```
## 按秩（即'高度'）合并
一般用rank[x] 数组，代表x这个元素在自己集合构成的森林中的层数。初始时，层数为0。
按秩合并可以通过减少森林的深度，来节约搜索的时间。
「按秩求并」而非100%「按高度求并」：
在应用带路径压缩的查询和按秩求并后，rank[root]记录的数字是树实际高度的一个上界，树的实际高度可能小于此值。
