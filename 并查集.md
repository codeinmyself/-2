# 并查集

## 适用场景
连通性问题

## 思想
并查集的思想就是，同一个连通区域内的所有点的根节点是同一个

# 数组并查集

## 适用范围
默认节点编号是0~n-1

## 例题
[统计无向图中无法互相到达点对数](https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/)

## 模板
```java
// 并查集，背住，不然没用，要背就背最标准的和完整的，别去背某些题目的精简/修改版，一点儿用没有
class UnionFind {
    int[] roots;
    int size; // 连通区域个数
    
    // 初始化节点，将每个节点的parent指向自己
    public UnionFind(int n) {
        roots = new int[n];
        for (int i = 0; i < n; i++) {
            roots[i] = i;
        }
        size=n;
    }

    // 作用：查找i的根节点，并在查找时进行路径上节点的parent重置，即路径压缩，最终指向同一个parent节点
    public int find(int i) {
        if (i == roots[i]) { // 说明找到最顶层的parent了，递归终止
            return i;
        }
        return roots[i] = find(roots[i]); // 这是一个赋值语句，并直接将值返回，
        /**
         *  可写成：
         *          int result=find(roots[i]);
         *          roots[i]=result;
         *          return result;
         */
    }

    // 作用：合并p，q两点，一般是将后者作为父节点，逻辑是先分别find，然后链接
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot != qRoot) {
            roots[pRoot] = qRoot;
            size--;
        }
    }
    
    // 作用： 判断两点是否连通
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public int count() {
        return this.size;
    }
}
```
# 哈希并查集

## 适用范围
节点编号不是0~n-1

## 例题
[最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

## 模板
```java
private class UnionFind{

        Map<Integer, Integer> parents;

        public UnionFind(int[] nums){
            this.parents = new HashMap<>();
            for(int num : nums) this.parents.put(num, num); // 初始单元素集合，parent指向自己
        }

        public int find(int x){
            if(parents.get(x) == x) return x;
            parents.put(x, find(parents.get(x)));
            return parents.get(x);
        }

        public void union(int x, int y){
            int xParent = find(x);
            int yParent = find(y);
            if (xParent != yParent) {
                parents.put(xParent, yParent);
            }
        }
    }
  ```
